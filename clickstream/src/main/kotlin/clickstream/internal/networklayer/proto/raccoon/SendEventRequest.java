// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: raccoon.proto

package clickstream.internal.networklayer.proto.raccoon;

/**
 * <pre>
 *`EventRequest` defines the contract to push events to Raccoon
 *An `EventRequest` allows you to push more than one events(batch). The events
 *are wrapped inside `events` repeated field. All of the fields on `EventRequest`
 *are required.
 * </pre>
 *
 * Protobuf type {@code raystack.raccoon.v1beta1.SendEventRequest}
 */
public  final class SendEventRequest extends
    com.google.protobuf.GeneratedMessageLite<
        SendEventRequest, SendEventRequest.Builder> implements
    // @@protoc_insertion_point(message_implements:raystack.raccoon.v1beta1.SendEventRequest)
    SendEventRequestOrBuilder {
  private SendEventRequest() {
    reqGuid_ = "";
    events_ = emptyProtobufList();
  }
  public static final int REQ_GUID_FIELD_NUMBER = 1;
  private String reqGuid_;
  /**
   * <pre>
   *`req_guid` is unique identifier of the request the client is making.
   *Raccoon uses the identifier to send response of the request. The client can handle the
   *response accordingly. For example, the client can retry the request in case the response is
   *giving `INTERNAL_ERROR` code with "publisher failed" reason.
   *This identifier is necessary because on event-based protocols like WebSocket the response is
   *returned asynchronously. If there is no identifier, no way the client can tell which response
   *belongs to which request.
   *Apart from sending response, `req_guid` is used to log some informations on 'debug' level. You can search the
   *debug logs with `ReqGUID` keyword.
   * </pre>
   *
   * <code>string req_guid = 1;</code>
   * @return The reqGuid.
   */
  @Override
  public String getReqGuid() {
    return reqGuid_;
  }
  /**
   * <pre>
   *`req_guid` is unique identifier of the request the client is making.
   *Raccoon uses the identifier to send response of the request. The client can handle the
   *response accordingly. For example, the client can retry the request in case the response is
   *giving `INTERNAL_ERROR` code with "publisher failed" reason.
   *This identifier is necessary because on event-based protocols like WebSocket the response is
   *returned asynchronously. If there is no identifier, no way the client can tell which response
   *belongs to which request.
   *Apart from sending response, `req_guid` is used to log some informations on 'debug' level. You can search the
   *debug logs with `ReqGUID` keyword.
   * </pre>
   *
   * <code>string req_guid = 1;</code>
   * @return The bytes for reqGuid.
   */
  @Override
  public com.google.protobuf.ByteString
      getReqGuidBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(reqGuid_);
  }
  /**
   * <pre>
   *`req_guid` is unique identifier of the request the client is making.
   *Raccoon uses the identifier to send response of the request. The client can handle the
   *response accordingly. For example, the client can retry the request in case the response is
   *giving `INTERNAL_ERROR` code with "publisher failed" reason.
   *This identifier is necessary because on event-based protocols like WebSocket the response is
   *returned asynchronously. If there is no identifier, no way the client can tell which response
   *belongs to which request.
   *Apart from sending response, `req_guid` is used to log some informations on 'debug' level. You can search the
   *debug logs with `ReqGUID` keyword.
   * </pre>
   *
   * <code>string req_guid = 1;</code>
   * @param value The reqGuid to set.
   */
  private void setReqGuid(
      String value) {
    Class<?> valueClass = value.getClass();
  
    reqGuid_ = value;
  }
  /**
   * <pre>
   *`req_guid` is unique identifier of the request the client is making.
   *Raccoon uses the identifier to send response of the request. The client can handle the
   *response accordingly. For example, the client can retry the request in case the response is
   *giving `INTERNAL_ERROR` code with "publisher failed" reason.
   *This identifier is necessary because on event-based protocols like WebSocket the response is
   *returned asynchronously. If there is no identifier, no way the client can tell which response
   *belongs to which request.
   *Apart from sending response, `req_guid` is used to log some informations on 'debug' level. You can search the
   *debug logs with `ReqGUID` keyword.
   * </pre>
   *
   * <code>string req_guid = 1;</code>
   */
  private void clearReqGuid() {
    
    reqGuid_ = getDefaultInstance().getReqGuid();
  }
  /**
   * <pre>
   *`req_guid` is unique identifier of the request the client is making.
   *Raccoon uses the identifier to send response of the request. The client can handle the
   *response accordingly. For example, the client can retry the request in case the response is
   *giving `INTERNAL_ERROR` code with "publisher failed" reason.
   *This identifier is necessary because on event-based protocols like WebSocket the response is
   *returned asynchronously. If there is no identifier, no way the client can tell which response
   *belongs to which request.
   *Apart from sending response, `req_guid` is used to log some informations on 'debug' level. You can search the
   *debug logs with `ReqGUID` keyword.
   * </pre>
   *
   * <code>string req_guid = 1;</code>
   * @param value The bytes for reqGuid to set.
   */
  private void setReqGuidBytes(
      com.google.protobuf.ByteString value) {
    checkByteStringIsUtf8(value);
    reqGuid_ = value.toStringUtf8();
    
  }

  public static final int SENT_TIME_FIELD_NUMBER = 2;
  private com.google.protobuf.Timestamp sentTime_;
  /**
   * <pre>
   *`sent_time` defines the time the request is sent.
   *`sent_time` is used to calculate various metrics. The main metric uses `sent_time` is duration from the
   *request is sent until the events are published.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp sent_time = 2;</code>
   */
  @Override
  public boolean hasSentTime() {
    return sentTime_ != null;
  }
  /**
   * <pre>
   *`sent_time` defines the time the request is sent.
   *`sent_time` is used to calculate various metrics. The main metric uses `sent_time` is duration from the
   *request is sent until the events are published.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp sent_time = 2;</code>
   */
  @Override
  public com.google.protobuf.Timestamp getSentTime() {
    return sentTime_ == null ? com.google.protobuf.Timestamp.getDefaultInstance() : sentTime_;
  }
  /**
   * <pre>
   *`sent_time` defines the time the request is sent.
   *`sent_time` is used to calculate various metrics. The main metric uses `sent_time` is duration from the
   *request is sent until the events are published.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp sent_time = 2;</code>
   */
  private void setSentTime(com.google.protobuf.Timestamp value) {
    value.getClass();
  sentTime_ = value;
    
    }
  /**
   * <pre>
   *`sent_time` defines the time the request is sent.
   *`sent_time` is used to calculate various metrics. The main metric uses `sent_time` is duration from the
   *request is sent until the events are published.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp sent_time = 2;</code>
   */
  @SuppressWarnings({"ReferenceEquality"})
  private void mergeSentTime(com.google.protobuf.Timestamp value) {
    value.getClass();
  if (sentTime_ != null &&
        sentTime_ != com.google.protobuf.Timestamp.getDefaultInstance()) {
      sentTime_ =
        com.google.protobuf.Timestamp.newBuilder(sentTime_).mergeFrom(value).buildPartial();
    } else {
      sentTime_ = value;
    }
    
  }
  /**
   * <pre>
   *`sent_time` defines the time the request is sent.
   *`sent_time` is used to calculate various metrics. The main metric uses `sent_time` is duration from the
   *request is sent until the events are published.
   * </pre>
   *
   * <code>.google.protobuf.Timestamp sent_time = 2;</code>
   */
  private void clearSentTime() {  sentTime_ = null;
    
  }

  public static final int EVENTS_FIELD_NUMBER = 3;
  private com.google.protobuf.Internal.ProtobufList<Event> events_;
  /**
   * <pre>
   *`events` is where the client put all the events wrapped in `Event`.
   *As mentioned above, the request allows the client to push more than one event. Normally you want to batch
   *the events to optimize the network call.
   * </pre>
   *
   * <code>repeated .raystack.raccoon.v1beta1.Event events = 3;</code>
   */
  @Override
  public java.util.List<Event> getEventsList() {
    return events_;
  }
  /**
   * <pre>
   *`events` is where the client put all the events wrapped in `Event`.
   *As mentioned above, the request allows the client to push more than one event. Normally you want to batch
   *the events to optimize the network call.
   * </pre>
   *
   * <code>repeated .raystack.raccoon.v1beta1.Event events = 3;</code>
   */
  public java.util.List<? extends EventOrBuilder>
      getEventsOrBuilderList() {
    return events_;
  }
  /**
   * <pre>
   *`events` is where the client put all the events wrapped in `Event`.
   *As mentioned above, the request allows the client to push more than one event. Normally you want to batch
   *the events to optimize the network call.
   * </pre>
   *
   * <code>repeated .raystack.raccoon.v1beta1.Event events = 3;</code>
   */
  @Override
  public int getEventsCount() {
    return events_.size();
  }
  /**
   * <pre>
   *`events` is where the client put all the events wrapped in `Event`.
   *As mentioned above, the request allows the client to push more than one event. Normally you want to batch
   *the events to optimize the network call.
   * </pre>
   *
   * <code>repeated .raystack.raccoon.v1beta1.Event events = 3;</code>
   */
  @Override
  public Event getEvents(int index) {
    return events_.get(index);
  }
  /**
   * <pre>
   *`events` is where the client put all the events wrapped in `Event`.
   *As mentioned above, the request allows the client to push more than one event. Normally you want to batch
   *the events to optimize the network call.
   * </pre>
   *
   * <code>repeated .raystack.raccoon.v1beta1.Event events = 3;</code>
   */
  public EventOrBuilder getEventsOrBuilder(
      int index) {
    return events_.get(index);
  }
  private void ensureEventsIsMutable() {
    com.google.protobuf.Internal.ProtobufList<Event> tmp = events_;
    if (!tmp.isModifiable()) {
      events_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
     }
  }

  /**
   * <pre>
   *`events` is where the client put all the events wrapped in `Event`.
   *As mentioned above, the request allows the client to push more than one event. Normally you want to batch
   *the events to optimize the network call.
   * </pre>
   *
   * <code>repeated .raystack.raccoon.v1beta1.Event events = 3;</code>
   */
  private void setEvents(
      int index, Event value) {
    value.getClass();
  ensureEventsIsMutable();
    events_.set(index, value);
  }
  /**
   * <pre>
   *`events` is where the client put all the events wrapped in `Event`.
   *As mentioned above, the request allows the client to push more than one event. Normally you want to batch
   *the events to optimize the network call.
   * </pre>
   *
   * <code>repeated .raystack.raccoon.v1beta1.Event events = 3;</code>
   */
  private void addEvents(Event value) {
    value.getClass();
  ensureEventsIsMutable();
    events_.add(value);
  }
  /**
   * <pre>
   *`events` is where the client put all the events wrapped in `Event`.
   *As mentioned above, the request allows the client to push more than one event. Normally you want to batch
   *the events to optimize the network call.
   * </pre>
   *
   * <code>repeated .raystack.raccoon.v1beta1.Event events = 3;</code>
   */
  private void addEvents(
      int index, Event value) {
    value.getClass();
  ensureEventsIsMutable();
    events_.add(index, value);
  }
  /**
   * <pre>
   *`events` is where the client put all the events wrapped in `Event`.
   *As mentioned above, the request allows the client to push more than one event. Normally you want to batch
   *the events to optimize the network call.
   * </pre>
   *
   * <code>repeated .raystack.raccoon.v1beta1.Event events = 3;</code>
   */
  private void addAllEvents(
      Iterable<? extends Event> values) {
    ensureEventsIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, events_);
  }
  /**
   * <pre>
   *`events` is where the client put all the events wrapped in `Event`.
   *As mentioned above, the request allows the client to push more than one event. Normally you want to batch
   *the events to optimize the network call.
   * </pre>
   *
   * <code>repeated .raystack.raccoon.v1beta1.Event events = 3;</code>
   */
  private void clearEvents() {
    events_ = emptyProtobufList();
  }
  /**
   * <pre>
   *`events` is where the client put all the events wrapped in `Event`.
   *As mentioned above, the request allows the client to push more than one event. Normally you want to batch
   *the events to optimize the network call.
   * </pre>
   *
   * <code>repeated .raystack.raccoon.v1beta1.Event events = 3;</code>
   */
  private void removeEvents(int index) {
    ensureEventsIsMutable();
    events_.remove(index);
  }

  public static SendEventRequest parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static SendEventRequest parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static SendEventRequest parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static SendEventRequest parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static SendEventRequest parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static SendEventRequest parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static SendEventRequest parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static SendEventRequest parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static SendEventRequest parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }
  public static SendEventRequest parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static SendEventRequest parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static SendEventRequest parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return (Builder) DEFAULT_INSTANCE.createBuilder();
  }
  public static Builder newBuilder(SendEventRequest prototype) {
    return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
  }

  /**
   * <pre>
   *`EventRequest` defines the contract to push events to Raccoon
   *An `EventRequest` allows you to push more than one events(batch). The events
   *are wrapped inside `events` repeated field. All of the fields on `EventRequest`
   *are required.
   * </pre>
   *
   * Protobuf type {@code raystack.raccoon.v1beta1.SendEventRequest}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        SendEventRequest, Builder> implements
      // @@protoc_insertion_point(builder_implements:raystack.raccoon.v1beta1.SendEventRequest)
      SendEventRequestOrBuilder {
    // Construct using clickstream.internal.networklayer.proto.raccoon.SendEventRequest.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }


    /**
     * <pre>
     *`req_guid` is unique identifier of the request the client is making.
     *Raccoon uses the identifier to send response of the request. The client can handle the
     *response accordingly. For example, the client can retry the request in case the response is
     *giving `INTERNAL_ERROR` code with "publisher failed" reason.
     *This identifier is necessary because on event-based protocols like WebSocket the response is
     *returned asynchronously. If there is no identifier, no way the client can tell which response
     *belongs to which request.
     *Apart from sending response, `req_guid` is used to log some informations on 'debug' level. You can search the
     *debug logs with `ReqGUID` keyword.
     * </pre>
     *
     * <code>string req_guid = 1;</code>
     * @return The reqGuid.
     */
    @Override
    public String getReqGuid() {
      return instance.getReqGuid();
    }
    /**
     * <pre>
     *`req_guid` is unique identifier of the request the client is making.
     *Raccoon uses the identifier to send response of the request. The client can handle the
     *response accordingly. For example, the client can retry the request in case the response is
     *giving `INTERNAL_ERROR` code with "publisher failed" reason.
     *This identifier is necessary because on event-based protocols like WebSocket the response is
     *returned asynchronously. If there is no identifier, no way the client can tell which response
     *belongs to which request.
     *Apart from sending response, `req_guid` is used to log some informations on 'debug' level. You can search the
     *debug logs with `ReqGUID` keyword.
     * </pre>
     *
     * <code>string req_guid = 1;</code>
     * @return The bytes for reqGuid.
     */
    @Override
    public com.google.protobuf.ByteString
        getReqGuidBytes() {
      return instance.getReqGuidBytes();
    }
    /**
     * <pre>
     *`req_guid` is unique identifier of the request the client is making.
     *Raccoon uses the identifier to send response of the request. The client can handle the
     *response accordingly. For example, the client can retry the request in case the response is
     *giving `INTERNAL_ERROR` code with "publisher failed" reason.
     *This identifier is necessary because on event-based protocols like WebSocket the response is
     *returned asynchronously. If there is no identifier, no way the client can tell which response
     *belongs to which request.
     *Apart from sending response, `req_guid` is used to log some informations on 'debug' level. You can search the
     *debug logs with `ReqGUID` keyword.
     * </pre>
     *
     * <code>string req_guid = 1;</code>
     * @param value The reqGuid to set.
     * @return This builder for chaining.
     */
    public Builder setReqGuid(
        String value) {
      copyOnWrite();
      instance.setReqGuid(value);
      return this;
    }
    /**
     * <pre>
     *`req_guid` is unique identifier of the request the client is making.
     *Raccoon uses the identifier to send response of the request. The client can handle the
     *response accordingly. For example, the client can retry the request in case the response is
     *giving `INTERNAL_ERROR` code with "publisher failed" reason.
     *This identifier is necessary because on event-based protocols like WebSocket the response is
     *returned asynchronously. If there is no identifier, no way the client can tell which response
     *belongs to which request.
     *Apart from sending response, `req_guid` is used to log some informations on 'debug' level. You can search the
     *debug logs with `ReqGUID` keyword.
     * </pre>
     *
     * <code>string req_guid = 1;</code>
     * @return This builder for chaining.
     */
    public Builder clearReqGuid() {
      copyOnWrite();
      instance.clearReqGuid();
      return this;
    }
    /**
     * <pre>
     *`req_guid` is unique identifier of the request the client is making.
     *Raccoon uses the identifier to send response of the request. The client can handle the
     *response accordingly. For example, the client can retry the request in case the response is
     *giving `INTERNAL_ERROR` code with "publisher failed" reason.
     *This identifier is necessary because on event-based protocols like WebSocket the response is
     *returned asynchronously. If there is no identifier, no way the client can tell which response
     *belongs to which request.
     *Apart from sending response, `req_guid` is used to log some informations on 'debug' level. You can search the
     *debug logs with `ReqGUID` keyword.
     * </pre>
     *
     * <code>string req_guid = 1;</code>
     * @param value The bytes for reqGuid to set.
     * @return This builder for chaining.
     */
    public Builder setReqGuidBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setReqGuidBytes(value);
      return this;
    }

    /**
     * <pre>
     *`sent_time` defines the time the request is sent.
     *`sent_time` is used to calculate various metrics. The main metric uses `sent_time` is duration from the
     *request is sent until the events are published.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp sent_time = 2;</code>
     */
    @Override
    public boolean hasSentTime() {
      return instance.hasSentTime();
    }
    /**
     * <pre>
     *`sent_time` defines the time the request is sent.
     *`sent_time` is used to calculate various metrics. The main metric uses `sent_time` is duration from the
     *request is sent until the events are published.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp sent_time = 2;</code>
     */
    @Override
    public com.google.protobuf.Timestamp getSentTime() {
      return instance.getSentTime();
    }
    /**
     * <pre>
     *`sent_time` defines the time the request is sent.
     *`sent_time` is used to calculate various metrics. The main metric uses `sent_time` is duration from the
     *request is sent until the events are published.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp sent_time = 2;</code>
     */
    public Builder setSentTime(com.google.protobuf.Timestamp value) {
      copyOnWrite();
      instance.setSentTime(value);
      return this;
      }
    /**
     * <pre>
     *`sent_time` defines the time the request is sent.
     *`sent_time` is used to calculate various metrics. The main metric uses `sent_time` is duration from the
     *request is sent until the events are published.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp sent_time = 2;</code>
     */
    public Builder setSentTime(
        com.google.protobuf.Timestamp.Builder builderForValue) {
      copyOnWrite();
      instance.setSentTime(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     *`sent_time` defines the time the request is sent.
     *`sent_time` is used to calculate various metrics. The main metric uses `sent_time` is duration from the
     *request is sent until the events are published.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp sent_time = 2;</code>
     */
    public Builder mergeSentTime(com.google.protobuf.Timestamp value) {
      copyOnWrite();
      instance.mergeSentTime(value);
      return this;
    }
    /**
     * <pre>
     *`sent_time` defines the time the request is sent.
     *`sent_time` is used to calculate various metrics. The main metric uses `sent_time` is duration from the
     *request is sent until the events are published.
     * </pre>
     *
     * <code>.google.protobuf.Timestamp sent_time = 2;</code>
     */
    public Builder clearSentTime() {  copyOnWrite();
      instance.clearSentTime();
      return this;
    }

    /**
     * <pre>
     *`events` is where the client put all the events wrapped in `Event`.
     *As mentioned above, the request allows the client to push more than one event. Normally you want to batch
     *the events to optimize the network call.
     * </pre>
     *
     * <code>repeated .raystack.raccoon.v1beta1.Event events = 3;</code>
     */
    @Override
    public java.util.List<Event> getEventsList() {
      return java.util.Collections.unmodifiableList(
          instance.getEventsList());
    }
    /**
     * <pre>
     *`events` is where the client put all the events wrapped in `Event`.
     *As mentioned above, the request allows the client to push more than one event. Normally you want to batch
     *the events to optimize the network call.
     * </pre>
     *
     * <code>repeated .raystack.raccoon.v1beta1.Event events = 3;</code>
     */
    @Override
    public int getEventsCount() {
      return instance.getEventsCount();
    }/**
     * <pre>
     *`events` is where the client put all the events wrapped in `Event`.
     *As mentioned above, the request allows the client to push more than one event. Normally you want to batch
     *the events to optimize the network call.
     * </pre>
     *
     * <code>repeated .raystack.raccoon.v1beta1.Event events = 3;</code>
     */
    @Override
    public Event getEvents(int index) {
      return instance.getEvents(index);
    }
    /**
     * <pre>
     *`events` is where the client put all the events wrapped in `Event`.
     *As mentioned above, the request allows the client to push more than one event. Normally you want to batch
     *the events to optimize the network call.
     * </pre>
     *
     * <code>repeated .raystack.raccoon.v1beta1.Event events = 3;</code>
     */
    public Builder setEvents(
        int index, Event value) {
      copyOnWrite();
      instance.setEvents(index, value);
      return this;
    }
    /**
     * <pre>
     *`events` is where the client put all the events wrapped in `Event`.
     *As mentioned above, the request allows the client to push more than one event. Normally you want to batch
     *the events to optimize the network call.
     * </pre>
     *
     * <code>repeated .raystack.raccoon.v1beta1.Event events = 3;</code>
     */
    public Builder setEvents(
        int index, Event.Builder builderForValue) {
      copyOnWrite();
      instance.setEvents(index,
          builderForValue.build());
      return this;
    }
    /**
     * <pre>
     *`events` is where the client put all the events wrapped in `Event`.
     *As mentioned above, the request allows the client to push more than one event. Normally you want to batch
     *the events to optimize the network call.
     * </pre>
     *
     * <code>repeated .raystack.raccoon.v1beta1.Event events = 3;</code>
     */
    public Builder addEvents(Event value) {
      copyOnWrite();
      instance.addEvents(value);
      return this;
    }
    /**
     * <pre>
     *`events` is where the client put all the events wrapped in `Event`.
     *As mentioned above, the request allows the client to push more than one event. Normally you want to batch
     *the events to optimize the network call.
     * </pre>
     *
     * <code>repeated .raystack.raccoon.v1beta1.Event events = 3;</code>
     */
    public Builder addEvents(
        int index, Event value) {
      copyOnWrite();
      instance.addEvents(index, value);
      return this;
    }
    /**
     * <pre>
     *`events` is where the client put all the events wrapped in `Event`.
     *As mentioned above, the request allows the client to push more than one event. Normally you want to batch
     *the events to optimize the network call.
     * </pre>
     *
     * <code>repeated .raystack.raccoon.v1beta1.Event events = 3;</code>
     */
    public Builder addEvents(
        Event.Builder builderForValue) {
      copyOnWrite();
      instance.addEvents(builderForValue.build());
      return this;
    }
    /**
     * <pre>
     *`events` is where the client put all the events wrapped in `Event`.
     *As mentioned above, the request allows the client to push more than one event. Normally you want to batch
     *the events to optimize the network call.
     * </pre>
     *
     * <code>repeated .raystack.raccoon.v1beta1.Event events = 3;</code>
     */
    public Builder addEvents(
        int index, Event.Builder builderForValue) {
      copyOnWrite();
      instance.addEvents(index,
          builderForValue.build());
      return this;
    }
    /**
     * <pre>
     *`events` is where the client put all the events wrapped in `Event`.
     *As mentioned above, the request allows the client to push more than one event. Normally you want to batch
     *the events to optimize the network call.
     * </pre>
     *
     * <code>repeated .raystack.raccoon.v1beta1.Event events = 3;</code>
     */
    public Builder addAllEvents(
        Iterable<? extends Event> values) {
      copyOnWrite();
      instance.addAllEvents(values);
      return this;
    }
    /**
     * <pre>
     *`events` is where the client put all the events wrapped in `Event`.
     *As mentioned above, the request allows the client to push more than one event. Normally you want to batch
     *the events to optimize the network call.
     * </pre>
     *
     * <code>repeated .raystack.raccoon.v1beta1.Event events = 3;</code>
     */
    public Builder clearEvents() {
      copyOnWrite();
      instance.clearEvents();
      return this;
    }
    /**
     * <pre>
     *`events` is where the client put all the events wrapped in `Event`.
     *As mentioned above, the request allows the client to push more than one event. Normally you want to batch
     *the events to optimize the network call.
     * </pre>
     *
     * <code>repeated .raystack.raccoon.v1beta1.Event events = 3;</code>
     */
    public Builder removeEvents(int index) {
      copyOnWrite();
      instance.removeEvents(index);
      return this;
    }

    // @@protoc_insertion_point(builder_scope:raystack.raccoon.v1beta1.SendEventRequest)
  }
  @Override
  @SuppressWarnings({"unchecked", "fallthrough"})
  protected final Object dynamicMethod(
      MethodToInvoke method,
      Object arg0, Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new SendEventRequest();
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case BUILD_MESSAGE_INFO: {
          Object[] objects = new Object[] {
            "reqGuid_",
            "sentTime_",
            "events_",
            Event.class,
          };
          String info =
              "\u0000\u0003\u0000\u0000\u0001\u0003\u0003\u0000\u0001\u0000\u0001\u0208\u0002\t" +
              "\u0003\u001b";
          return newMessageInfo(DEFAULT_INSTANCE, info, objects);
      }
      // fall through
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        com.google.protobuf.Parser<SendEventRequest> parser = PARSER;
        if (parser == null) {
          synchronized (SendEventRequest.class) {
            parser = PARSER;
            if (parser == null) {
              parser =
                  new DefaultInstanceBasedParser<SendEventRequest>(
                      DEFAULT_INSTANCE);
              PARSER = parser;
            }
          }
        }
        return parser;
    }
    case GET_MEMOIZED_IS_INITIALIZED: {
      return (byte) 1;
    }
    case SET_MEMOIZED_IS_INITIALIZED: {
      return null;
    }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:raystack.raccoon.v1beta1.SendEventRequest)
  private static final SendEventRequest DEFAULT_INSTANCE;
  static {
    SendEventRequest defaultInstance = new SendEventRequest();
    // New instances are implicitly immutable so no need to make
    // immutable.
    DEFAULT_INSTANCE = defaultInstance;
    com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
      SendEventRequest.class, defaultInstance);
  }

  public static SendEventRequest getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<SendEventRequest> PARSER;

  public static com.google.protobuf.Parser<SendEventRequest> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

