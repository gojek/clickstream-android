package clickstream.internal.eventprocessor

import clickstream.CSEvent
import clickstream.api.CSInfo
import clickstream.config.CSEventProcessorConfig
import clickstream.health.constant.CSEventTypesConstant
import clickstream.health.model.CSHealthEvent
import clickstream.internal.CSEventInternal
import clickstream.protoName
import clickstream.internal.eventscheduler.CSEventScheduler
import clickstream.logger.CSLogger
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.ExperimentalCoroutinesApi

/**
 * This is responsible for ingesting analytics events generated by app,adding relevant keys,
 * and forwarding the events to [CSEventScheduler].
 *
 * @param eventScheduler used for scheduling events
 * @param dispatcher used for dispatching events serially
 * @param logger used for logging
 */
@ExperimentalCoroutinesApi
internal class CSEventProcessor(
    private val config: CSEventProcessorConfig,
    private val eventScheduler: CSEventScheduler,
    private val dispatcher: CoroutineDispatcher,
    private val logger: CSLogger,
) {

    /**
     * Creates event object and forwards to EventScheduler.
     *
     * @param event [CSEvent] which holds guid, timestamp and message
     */
    suspend fun trackEvent(event: CSEventInternal) {
        logger.debug { "CSEventProcessor#trackEvent" }
        val (eventGuid, eventName) = when (event) {
            is CSEventInternal.CSEvent -> event.guid to event.message.protoName()
            is CSEventInternal.CSBytesEvent -> event.guid to event.eventName
        }

        logger.debug { "CSEventProcessor#trackEvent" }

        when {
            config.realtimeEvents.contains(eventName) -> {
                eventScheduler.scheduleEvent(event)
            }
            config.instantEvent.contains(eventName) -> {
                eventScheduler.sendInstantEvent(event)
            }
            else -> {
                eventScheduler.scheduleEvent(event)
            }
        }
    }
}
