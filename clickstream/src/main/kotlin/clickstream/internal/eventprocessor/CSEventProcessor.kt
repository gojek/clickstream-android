package clickstream.internal.eventprocessor

import clickstream.CSEvent
import clickstream.config.CSEventProcessorConfig
import clickstream.health.CSEventNames
import clickstream.health.CSHealthEvent
import clickstream.health.CSHealthEventRepository
import clickstream.health.CSInfo
import clickstream.health.EventTypes
import clickstream.internal.eventscheduler.CSEventScheduler
import clickstream.logger.CSLogger
import clickstream.protoName
import java.util.Locale
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.ExperimentalCoroutinesApi

/**
 * This is responsible for ingesting analytics events generated by app,adding relevant keys,
 * and forwarding the events to [CSEventScheduler].
 *
 * @param eventScheduler used for scheduling events
 * @param dispatcher used for dispatching events serially
 * @param logger used for logging
 * @param healthEventRepository used for tracking health events
 */
@ExperimentalCoroutinesApi
internal class CSEventProcessor(
    private val config: CSEventProcessorConfig,
    private val eventScheduler: CSEventScheduler,
    private val dispatcher: CoroutineDispatcher,
    private val logger: CSLogger,
    private val healthEventRepository: CSHealthEventRepository,
    private val info: CSInfo
) {

    /**
     * Creates event object and forwards to EventScheduler.
     *
     * @param event [CSEvent] which holds guid, timestamp and message
     */
    suspend fun trackEvent(event: CSEvent) {
        logger.debug { "CSEventProcessor#trackEvent" }
        logHealthEvent(
            eventName = CSEventNames.ClickStreamEventReceived.value,
            eventId = event.guid.plus("_")
                .plus(event.message::class.simpleName.orEmpty().toLowerCase(Locale.getDefault()))
        )
        logHealthEvent(
            eventName = CSEventNames.ClickStreamEventObjectCreated.value,
            eventId = event.guid
        )
        val eventName = event.message.protoName()
        when {
            config.realtimeEvents.contains(eventName) -> {
                eventScheduler.scheduleEvent(event)
            }
            config.instantEvent.contains(eventName) -> {
                eventScheduler.sendInstantEvent(event)
            }
            else -> {
                eventScheduler.scheduleEvent(event)
            }
        }
    }

    private suspend fun logHealthEvent(eventName: String, eventId: String) {
        healthEventRepository.insertHealthEvent(
            CSHealthEvent(
                eventName = eventName,
                eventType = EventTypes.AGGREGATE,
                eventId = eventId,
                appVersion = info.appInfo.appVersion
            )
        )
    }
}
